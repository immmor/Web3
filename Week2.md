# GMP 是 Go 语言实现高效并发的核心调度机制，由三个核心组件构成：

G（Goroutine）：即协程，是 Go 语言中的轻量级线程，包含执行栈、程序计数器等信息，由 Go 运行时（Runtime）管理，而非操作系统。
M（Machine）：代表操作系统的物理线程（OS Thread），负责执行 G 的代码。
P（Processor）：逻辑处理器，是连接 G 和 M 的中间层，包含运行队列（G 的队列）、线程上下文等，用于调度 G 在 M 上执行。

工作原理：

每个 P 维护一个本地 G 队列，同时存在一个全局 G 队列。
当 M 绑定 P 后，会从 P 的本地队列或全局队列中取出 G 执行。
若 G 执行阻塞操作（如 IO），M 会释放 P，让其他 M 可以绑定该 P 继续执行其他 G，避免资源浪费。
支持 "工作窃取"：当某个 P 的本地队列空了，会从其他 P 的队列或全局队列中 "窃取"G 来执行，平衡负载。

# sync包的使用
## 一、sync.Map是并发安全的键值对映射，专为读多写少场景设计，避免了使用map+mutex的繁琐。
## 二、sync.Once用于保证某段代码在程序生命周期内仅执行一次，即使被多个协程同时调用。
## 三、sync.Pool是一个临时对象缓存池，用于存储可复用的对象，减少内存分配和 GC 压力。
## 四、sync.WaitGroup用于等待一组协程完成，类似于线程池中的任务计数器，可以方便地实现并发控制。
## 五、sync.SingleFlight用于合并相同的并发请求，避免重复计算或重复调用外部资源。

- Context包是 Go 语言中用于控制并发操作和传递上下文信息的标准库，它提供了一种机制来传递请求范围的数据、取消信号、截止时间等。
- Channel（有buffer）：有缓冲通道有一个固定大小的缓冲区，发送和接收操作的阻塞行为取决于缓冲区的状态。
- Channel（无buffer）：无缓冲通道没有数据缓冲区，发送和接收操作是同步阻塞的。

## Error包是 Go 语言标准库中用于处理错误的标准接口和函数，它提供了一种统一的方式来表示和处理错误。
## ErrorGroup包是 Go 语言标准库中用于处理一组并发操作的错误的标准库，它提供了一种机制来等待一组并发操作完成，并收集它们的错误。


